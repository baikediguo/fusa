# fusa - FUnctional SAfety evaluations for ML accelerators

## Objective
1. Goal: Evaluate the functional safety of an AI accelerator by measuring the proportion of "unsafe" faults through fault-injection experiments.
2. Safety Criterion: A fault is "unsafe", if it causes the inference accuracy to fall below 90%.
3. Challenge: The AI accelerator's enormous fault space makes full-scale fault simulation impossible. Thus, only a subset of faults can be explicitely simulated to estimate the proportion of "unsafe" faults.

## Fault injection using Pyverilog in a single PE

[Pyverilog](https://github.com/PyHDI/Pyverilog) can parse the Verilog netlists into Abstract Syntax Trees (ASTs) and generate verilog code from ASTs. ASTs can be modified to inject faults.

Golden Simulation:
* Compile and run the gate-level model with `make golden`
* Outputs golden simulation results in `work.nogit/golden_sim_output.log`

Fault Injection:
* Model: single stuck-at fault
* `gatesa_fault_injection.py` traverses all gates (such as AND/OR/XOR...) and performs 'fault injection' on each gate—such as forcing the output to 0 (stuck-at-0) or 1 (stuck-at-1). Injects faults into all gate output ports, regardless of whether they are wires or registers, by inserting an assign statement to achieve 'generalized node-level' injection, ensuring no output nodes are skipped. This indirectly covers all Q-end registers and wire nodes.
* For each fault version, generate a modified Verilog file, call Icarus Verilog (iverilog) to run functional simulation, and extract the output.

Evaluation:
* `calc_rmse_faults.py` reads simulation output logs from both golden (fault-free) and fault-injected runs, compares the numerical results, and computes the RMSE (Root Mean Square Error) for each fault.
* This script is intended for use with log files where each line contains a field like `o_sum= ...`, as produced by the recommended Verilog testbench.
* Measure RMSE = sqrt(mean((faulty_output - golden_output)^2))

## TODO

* Perform subsequent whole - accelerator - level simulation (input inference and accuracy evaluation) by assuming the code can load and run the entire accelerator model.
* Use the output RMSE and FS as a measure of fault impact.


## Environment Setup Notes
For a quick setup, you can use the following command to install all dependencies at once:

pip install -r requirements.txt

Alternatively, if you prefer to install the dependencies step-by-step, please follow the instructions below:
* [Pyverilog](https://github.com/PyHDI/Pyverilog): `pip install pyverilog`
* [iVerilog](https://steveicarus.github.io/iverilog/)
* On Windows: Use [mingw-w64](https://www.mingw-w64.org) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/install)
* Technology libraries need to be downloaded separately (Optional):
  * Synopsys Educational Design Kit (SAED90nm)
  * [Nangate Open Cell Library](https://github.com/JulianKemmerer/Drexel-ECEC575/tree/master/Encounter/NangateOpenCellLibrary)

## Below is a detailed guide for the experimental process, broken down into 5 steps to provide clear instructions：

## Step 1: Standard Cell Library Generation
   Script: generate_cell.code.py
   Input: Synthesized netlist file pe.synth_dct.v
   Output: Verilog cell library cells.v
   Functionality:
    * Automatically parses standard cell instances (e.g., DFFX1, NAND2X0) from the netlist
    * Generates behavioral Verilog models for each cell type based on predefined templates
    * Preserves original port ordering for LEC compatibility
    * Handles special register outputs for sequential elements
![Image](https://github.com/user-attachments/assets/8b267698-610a-424f-a8d3-e5c0aae08869)
## Step 2: Testbench Initialization
   Requirements:
   * Place cells.v and tb.v in the same directory
   * Testbench (tb.v) must instantiate the PE module with correct port mappings
   * Ensure timescale 1ns/1ps directive exists for proper timing simulation
     
   Key Components:
   * Clock generator (100MHz, 50% duty cycle)
   * Reset sequence (20ns active period)
   * 1024 diversified stimulus vectors


## Step 3: Fault Injection
   Script: gatesa_fault_injection.py
   Process:
   * Golden simulation (fault-free baseline)
   * Automatic fault target extraction from netlist
   * Stuck-at fault injection (0/1) on all cell outputs
   * Parallel simulation of faulty circuits
![Image](https://github.com/user-attachments/assets/c6d6474c-b751-41e4-a8d2-65b30cc8356e)

## Step 4: RMSE calculation 
   Script: cal_rmse_fault.py
   Metrics Calculation:
   * Computes RMSE between faulty and golden outputs
   * Filters valid data points (non-NaN comparisons)
   * Identifies critical faults exceeding threshold

   Output Files:
   * rmse_results.csv - Structured data with columns
![Image](https://github.com/user-attachments/assets/96794db8-70b2-46b4-9fff-afee700546db)

## Step 5: Fault Coverage Analysis
   Script Function: calc_fault_coverage.py
   Input File: rmse_results.csv (generated by RMSE calculation)
   * The threshold and the number of test vectors can be dynamically set.
   * Identifies sensitive paths as faults whose RMSE exceeds a predefined threshold.
   * Computes coverage as the ratio of critical faults to total injected faults.
   * Outputs both the coverage percentage and a list of critical faults (saved to critical_fs.txt)".
 ![Image](https://github.com/user-attachments/assets/407e2ed1-79fc-4acb-9f17-278fe03e2690)
       
